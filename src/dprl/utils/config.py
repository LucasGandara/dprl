"""
Base configuration classes for DPRL algorithms.

This module provides a SOLID-compliant base class for algorithm configurations.
Each algorithm module (e.g., VPG) should define its own config class extending
BaseConfig.
"""

from pathlib import Path
from typing import Any, Self, get_args, get_origin

import click
import yaml
from pydantic import BaseModel, ConfigDict, ValidationError


class BaseConfig(BaseModel):
    """
    Base configuration class for all DPRL algorithms.

    Subclasses define algorithm-specific fields. This base class provides:
    - YAML loading with Pydantic validation
    - Template generation with comments
    - Click default_map conversion for CLI integration

    Example:
        class VPGConfig(BaseConfig):
            epochs: int = Field(default=50, description="Number of epochs")
            lr: float = Field(default=0.001, description="Learning rate")
    """

    model_config = ConfigDict(
        populate_by_name=True,
        extra="forbid",
    )

    @classmethod
    def load_from_yaml(cls, path: Path) -> Self:
        """
        Load and validate configuration from YAML file.

        Args:
            path: Path to the YAML configuration file.

        Returns:
            Validated configuration instance.

        Raises:
            FileNotFoundError: If the config file does not exist.
            yaml.YAMLError: If the YAML file has syntax errors.
            ValidationError: If the config values are invalid.
        """
        if not path.exists():
            raise FileNotFoundError(f"Configuration file not found: {path}")

        with open(path) as f:
            try:
                raw = yaml.safe_load(f) or {}
            except yaml.YAMLError as e:
                raise yaml.YAMLError(
                    f"YAML syntax error in '{path}': {e}"
                ) from e

        return cls.model_validate(raw)

    @classmethod
    def generate_template(cls, path: Path) -> None:
        """
        Generate a YAML template file with defaults and comments.

        Args:
            path: Path where the template will be written.
        """
        schema = cls.model_json_schema()
        properties = schema.get("properties", {})

        lines = [
            f"# {cls.__name__} Configuration",
            "# Generated by: --generate-config",
            "",
        ]

        for field_name, field_info in cls.model_fields.items():
            alias = field_info.alias or field_name
            default = field_info.default
            description = field_info.description or ""

            if description:
                lines.append(f"# {description}")

            prop = properties.get(field_name, {})
            if "enum" in prop:
                valid_values = ", ".join(prop["enum"])
                lines.append(f"# Valid values: {valid_values}")

            annotation = cls.model_fields[field_name].annotation
            if get_origin(annotation) is type(None):
                pass
            elif hasattr(annotation, "__args__"):
                origin = get_origin(annotation)
                if origin is not None:
                    args = get_args(annotation)
                    if all(isinstance(a, str) for a in args):
                        valid_values = ", ".join(args)
                        lines.append(f"# Valid values: {valid_values}")

            lines.append(f"{alias}: {default}")
            lines.append("")

        path.write_text("\n".join(lines))

    def to_click_default_map(self) -> dict[str, Any]:
        """
        Convert config to Click default_map format.

        Returns:
            Dictionary with field aliases as keys for Click integration.
        """
        return self.model_dump(by_alias=True)

    def to_yaml(self, path: Path) -> None:
        """
        Save configuration to a YAML file.

        Args:
            path: Path where the YAML file will be written.
        """
        data = self.model_dump(by_alias=True)
        with open(path, "w") as f:
            yaml.safe_dump(data, f, default_flow_style=False, sort_keys=False)


def format_validation_error(
    error: ValidationError,
    config_path: str,
    config_class: type[BaseConfig],
) -> str:
    """
    Format a Pydantic ValidationError for user-friendly CLI output.

    Args:
        error: The Pydantic validation error.
        config_path: Path to the config file (for error message).
        config_class: The config class (to list valid fields).

    Returns:
        Formatted error message string.
    """
    lines = [f"Configuration Error in '{config_path}':", ""]

    valid_fields = [
        field_info.alias or field_name
        for field_name, field_info in config_class.model_fields.items()
    ]

    for err in error.errors():
        field = ".".join(str(loc) for loc in err["loc"])
        msg = err["msg"]
        err_type = err["type"]

        if err_type == "extra_forbidden":
            lines.append(f"  {field}: Extra inputs are not permitted.")
            lines.append(f"         Valid fields: {', '.join(valid_fields)}")
        else:
            lines.append(f"  {field}: {msg}")
            if "input" in err:
                lines.append(f"          Got: {err['input']!r}")

        lines.append("")

    return "\n".join(lines)


def config_option(config_class: type[BaseConfig]):
    """
    Decorator factory for --config CLI option.

    Creates a Click option that loads a YAML config file and injects
    values into ctx.default_map. CLI arguments override config values.

    Args:
        config_class: The BaseConfig subclass to use for validation.

    Returns:
        A Click decorator that adds --config option.

    Example:
        @click.command()
        @config_option(VPGConfig)
        @click.option("--epochs", default=50)
        def train(epochs):
            ...
    """

    def callback(ctx: click.Context, param: click.Parameter, value: str | None):
        if value is None:
            return None

        path = Path(value)

        try:
            config = config_class.load_from_yaml(path)
        except FileNotFoundError:
            raise click.BadParameter(
                f"Configuration file not found: {path}"
            )
        except yaml.YAMLError as e:
            raise click.BadParameter(str(e))
        except ValidationError as e:
            msg = format_validation_error(e, str(path), config_class)
            raise click.BadParameter(msg)

        ctx.default_map = ctx.default_map or {}
        ctx.default_map.update(config.to_click_default_map())
        return value

    return click.option(
        "--config",
        type=click.Path(),
        callback=callback,
        expose_value=False,
        is_eager=True,
        help="Path to YAML configuration file.",
    )


def generate_config_option(config_class: type[BaseConfig]):
    """
    Decorator factory for --generate-config CLI option.

    Creates a Click option that generates a YAML template file with
    default values and comments, then exits.

    Args:
        config_class: The BaseConfig subclass to use for template.

    Returns:
        A Click decorator that adds --generate-config option.

    Example:
        @click.command()
        @generate_config_option(VPGConfig)
        def train():
            ...
    """

    def callback(ctx: click.Context, param: click.Parameter, value: bool):
        if not value:
            return

        class_name = config_class.__name__
        template_name = class_name.lower().replace("config", "_config")
        output_path = Path(f"{template_name}_template.yaml")

        config_class.generate_template(output_path)
        click.echo(f"Generated configuration template: {output_path}")
        ctx.exit(0)

    return click.option(
        "--generate-config",
        is_flag=True,
        callback=callback,
        expose_value=False,
        is_eager=True,
        help="Generate a YAML configuration template and exit.",
    )
