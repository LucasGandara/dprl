# Research: YAML Configuration File Support

**Feature**: 005-yaml-config
**Date**: 2026-01-27

## Research Tasks

### 1. SOLID-Compliant Config Architecture

**Decision**: Abstract base class `BaseConfig` in utils, concrete configs in
algorithm modules

**Rationale**: Following SOLID principles:
- Single Responsibility: Base handles I/O; subclasses define fields
- Open/Closed: Extend via inheritance, don't modify base
- Liskov Substitution: All configs work with base class utilities
- Interface Segregation: Minimal methods on base
- Dependency Inversion: CLI depends on BaseConfig abstraction

**Alternatives considered**:
- Protocol-based approach - More Pythonic but less discoverable for users
- Mixin composition - Adds complexity without clear benefit here
- No base class - Would duplicate loading/generation logic

**Class hierarchy**:
```
BaseConfig (src/dprl/utils/config.py)
    ├── load_from_yaml(path) → Self
    ├── generate_template(path) → None
    └── to_click_default_map() → dict

VPGConfig (src/dprl/algorithms/vpg/config.py)
    └── extends BaseConfig with VPG-specific fields
```

### 2. Pydantic BaseModel as Foundation

**Decision**: BaseConfig extends Pydantic's BaseModel

**Rationale**: Pydantic provides:
- Type validation and coercion out of the box
- Field metadata (description, alias) for template generation
- `model_validate()` for YAML dict parsing
- `model_json_schema()` for introspection
- `extra="forbid"` for unknown field detection

**Implementation**:
```python
from pydantic import BaseModel, ConfigDict
from abc import ABC
from pathlib import Path
from typing import Self
import yaml

class BaseConfig(BaseModel, ABC):
    """Base configuration class for all DPRL algorithms."""

    model_config = ConfigDict(
        populate_by_name=True,
        extra="forbid",
    )

    @classmethod
    def load_from_yaml(cls, path: Path) -> Self:
        """Load and validate config from YAML file."""
        with open(path) as f:
            raw = yaml.safe_load(f) or {}
        return cls.model_validate(raw)

    def generate_template(self, path: Path) -> None:
        """Generate YAML template with comments."""
        # Uses model_json_schema() for field metadata
        ...

    def to_click_default_map(self) -> dict[str, Any]:
        """Convert to Click default_map format."""
        return self.model_dump(by_alias=True)
```

### 3. Click Integration Pattern

**Decision**: Factory function returning Click callback

**Rationale**: Allows passing the config class as a parameter while returning
a Click-compatible callback. Clean separation between config definition and
CLI integration.

**Implementation**:
```python
def config_option(config_class: type[BaseConfig]):
    """Decorator factory for --config option."""
    def callback(ctx, param, value):
        if value is None:
            return None
        try:
            config = config_class.load_from_yaml(Path(value))
            ctx.default_map = ctx.default_map or {}
            ctx.default_map.update(config.to_click_default_map())
        except ValidationError as e:
            raise click.BadParameter(format_validation_error(e))
        return value
    return click.option(
        "--config",
        type=click.Path(exists=True),
        callback=callback,
        expose_value=False,
        is_eager=True,
    )
```

### 4. Template Generation with Comments

**Decision**: String formatting using Pydantic's JSON schema metadata

**Rationale**: Pydantic's `model_json_schema()` provides field descriptions.
We iterate over fields and format each with its description as a comment.

**Template format**:
```yaml
# VPG Training Configuration
# Generated by: python vpg_cartpole.py --generate-config

# Number of epochs to train for
epochs: 50

# Learning rate
lr: 0.001

# Number of units in the hidden layer
hidden-layer-units: 64

# Advantage expression to use
# Valid values: total_reward, reward_to_go, baselined
advantage-expression: reward_to_go
```

### 5. Error Message Formatting

**Decision**: Custom formatter wrapping Pydantic ValidationError

**Rationale**: Pydantic errors are detailed but technical. We wrap them to:
- Show the config file path
- List valid fields for unknown field errors
- Show allowed values for Literal type errors

**Implementation**:
```python
def format_validation_error(
    error: ValidationError,
    config_path: str,
    config_class: type[BaseConfig]
) -> str:
    lines = [f"Configuration Error in '{config_path}':", ""]
    valid_fields = list(config_class.model_fields.keys())

    for err in error.errors():
        field = ".".join(str(loc) for loc in err["loc"])
        msg = err["msg"]

        if err["type"] == "extra_forbidden":
            lines.append(f"  {field}: Extra inputs are not permitted.")
            lines.append(f"         Valid fields: {', '.join(valid_fields)}")
        else:
            lines.append(f"  {field}: {msg}")

        lines.append("")

    return "\n".join(lines)
```

### 6. VPGConfig Field Definitions

**Decision**: Define fields matching existing CLI options with aliases

**Rationale**: YAML uses hyphenated keys for readability; Python uses
underscores. Pydantic aliases handle the mapping.

**Fields**:
```python
class VPGConfig(BaseConfig):
    """Configuration for VPG algorithm."""

    epochs: int = Field(
        default=50,
        ge=1,
        description="Number of epochs to train for"
    )

    lr: float = Field(
        default=0.001,
        gt=0,
        description="Learning rate"
    )

    hidden_layer_units: int = Field(
        default=64,
        ge=1,
        alias="hidden-layer-units",
        description="Number of units in the hidden layer"
    )

    advantage_expression: Literal[
        "total_reward", "reward_to_go", "baselined"
    ] = Field(
        default="reward_to_go",
        alias="advantage-expression",
        description="Advantage expression to use"
    )
```

## Summary

Architecture follows SOLID principles with BaseConfig as the reusable
abstraction in utils and VPGConfig as the algorithm-specific implementation.
Pydantic provides type safety, validation, and schema introspection. Click
integration uses callback factories for clean decorator usage.

---

## Phase 2: Config Saving with Experiments

**Date**: 2026-01-27
**Context**: Config loading is complete. Now saving config with experiments
for reproducibility (Constitution III).

### Q1: How should config be passed to save_experiment_details?

**Decision**: Add optional `config: BaseConfig | None` parameter

**Rationale**:
- Maintains backward compatibility (parameter is optional)
- Uses existing BaseConfig type for type safety
- Follows existing pattern of optional parameters in save_experiment_details

**Alternatives Considered**:
- Pass config as part of `aditional_data` dict → Rejected: loses type info
- Create new function `save_experiment_with_config` → Rejected: proliferation

### Q2: What format should saved config use?

**Decision**: YAML file (`config.yaml`) in experiment folder

**Rationale**:
- Human-readable and editable
- Consistent with input format (users provide YAML)
- Easy to copy/reuse for new experiments
- Aligns with Constitution III: "Training configurations MUST be serializable
  (YAML/JSON)"

**Alternatives Considered**:
- JSON → Rejected: less readable, no comments
- Pickle inside .tar → Rejected: not human-readable
- Include in policy.tar → Rejected: couples config to PyTorch format

### Q3: How to serialize BaseConfig to YAML?

**Decision**: Use Pydantic's `model_dump(by_alias=True)` + PyYAML

**Implementation**:
```python
# In BaseConfig class
def to_yaml(self, path: Path) -> None:
    """Save configuration to YAML file."""
    data = self.model_dump(by_alias=True)
    with open(path, 'w') as f:
        yaml.safe_dump(data, f, default_flow_style=False)
```

### Q4: Should config be loaded when loading experiments?

**Decision**: Yes, add utility function `load_config_from_experiment()`

**Rationale**:
- Enables full reproducibility (reload model + config)
- Optional - returns None if config.yaml doesn't exist (backward compat)

### Q5: How should examples pass config to save?

**Decision**: Construct VPGConfig from CLI parameters

**Rationale**:
- CLI parameters already contain the effective config (whether from YAML or CLI)
- Captures the actual values used, including any CLI overrides

**Implementation**:
```python
# In vpg_cartpole.py
config = VPGConfig(
    epochs=epochs,
    lr=lr,
    hidden_layer_units=hidden_layer_units,
    advantage_expression=advantage_expression,
)
save_experiment_details(
    name="vpg",
    policy=value_function,
    config=config,
    aditional_data={...},
)
```

### Implementation Approach

1. **Add `to_yaml()` method to BaseConfig** - serialize config to YAML file
2. **Modify `save_experiment_details()`** - accept optional config parameter
3. **Add `load_config_from_experiment()` utility** - load config from saved exp
4. **Update `vpg_cartpole.py`** - pass config when saving
5. **Update `vpg_flappy_bird.py`** - same pattern
6. **Add unit tests** - verify config saving/loading
